//
// Generated by Bluespec Compiler, version 2021.12.1-27-g9a7d5e05 (build 9a7d5e05)
//
// On Wed Nov 30 04:35:35 IST 2022
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mktb_float(CLK,
		  RST_N);
  input  CLK;
  input  RST_N;

  // register golden_index
  reg [22 : 0] golden_index;
  wire [22 : 0] golden_index$D_IN;
  wire golden_index$EN;

  // register read_index
  reg [22 : 0] read_index;
  wire [22 : 0] read_index$D_IN;
  wire read_index$EN;

  // ports of submodule fadd
  wire [66 : 0] fadd$send_operands;
  wire [37 : 0] fadd$receive;
  wire fadd$EN_send;

  // ports of submodule ff_golden_output
  wire [36 : 0] ff_golden_output$D_IN, ff_golden_output$D_OUT;
  wire ff_golden_output$CLR,
       ff_golden_output$DEQ,
       ff_golden_output$EMPTY_N,
       ff_golden_output$ENQ,
       ff_golden_output$FULL_N;

  // ports of submodule stimulus
  wire [103 : 0] stimulus$D_IN, stimulus$D_OUT_1;
  wire [22 : 0] stimulus$ADDR_1,
		stimulus$ADDR_2,
		stimulus$ADDR_3,
		stimulus$ADDR_4,
		stimulus$ADDR_5,
		stimulus$ADDR_IN;
  wire stimulus$WE;

  // remaining internal signals
  wire fadd_receive__4_BITS_36_TO_5_6_EQ_ff_golden_ou_ETC___d19;

  // submodule fadd
  mk_fpu_add_sub_sp_instance fadd(.CLK(CLK),
				  .RST_N(RST_N),
				  .send_operands(fadd$send_operands),
				  .EN_send(fadd$EN_send),
				  .RDY_send(),
				  .receive(fadd$receive),
				  .RDY_receive());

  // submodule ff_golden_output
  FIFO2 #(.width(32'd37), .guarded(1'd1)) ff_golden_output(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(ff_golden_output$D_IN),
							   .ENQ(ff_golden_output$ENQ),
							   .DEQ(ff_golden_output$DEQ),
							   .CLR(ff_golden_output$CLR),
							   .D_OUT(ff_golden_output$D_OUT),
							   .FULL_N(ff_golden_output$FULL_N),
							   .EMPTY_N(ff_golden_output$EMPTY_N));

  // submodule stimulus
  RegFileLoad #(.file("input.txt"),
		.addr_width(32'd23),
		.data_width(32'd104),
		.lo(23'd0),
		.hi(23'd7496190),
		.binary(1'd0)) stimulus(.CLK(CLK),
					.ADDR_1(stimulus$ADDR_1),
					.ADDR_2(stimulus$ADDR_2),
					.ADDR_3(stimulus$ADDR_3),
					.ADDR_4(stimulus$ADDR_4),
					.ADDR_5(stimulus$ADDR_5),
					.ADDR_IN(stimulus$ADDR_IN),
					.D_IN(stimulus$D_IN),
					.WE(stimulus$WE),
					.D_OUT_1(stimulus$D_OUT_1),
					.D_OUT_2(),
					.D_OUT_3(),
					.D_OUT_4(),
					.D_OUT_5());

  // register golden_index
  assign golden_index$D_IN = golden_index + 23'd1 ;
  assign golden_index$EN = ff_golden_output$EMPTY_N && fadd$receive[37] ;

  // register read_index
  assign read_index$D_IN = read_index + 23'd1 ;
  assign read_index$EN = ff_golden_output$FULL_N ;

  // submodule fadd
  assign fadd$send_operands = { stimulus$D_OUT_1[103:40], 3'd1 } ;
  assign fadd$EN_send = ff_golden_output$FULL_N ;

  // submodule ff_golden_output
  assign ff_golden_output$D_IN =
	     { stimulus$D_OUT_1[39:8], stimulus$D_OUT_1[4:0] } ;
  assign ff_golden_output$ENQ = ff_golden_output$FULL_N ;
  assign ff_golden_output$DEQ = ff_golden_output$EMPTY_N && fadd$receive[37] ;
  assign ff_golden_output$CLR = 1'b0 ;

  // submodule stimulus
  assign stimulus$ADDR_1 = read_index ;
  assign stimulus$ADDR_2 = 23'h0 ;
  assign stimulus$ADDR_3 = 23'h0 ;
  assign stimulus$ADDR_4 = 23'h0 ;
  assign stimulus$ADDR_5 = 23'h0 ;
  assign stimulus$ADDR_IN = 23'h0 ;
  assign stimulus$D_IN = 104'h0 ;
  assign stimulus$WE = 1'b0 ;

  // remaining internal signals
  assign fadd_receive__4_BITS_36_TO_5_6_EQ_ff_golden_ou_ETC___d19 =
	     fadd$receive[36:5] == ff_golden_output$D_OUT[36:5] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        golden_index <= `BSV_ASSIGNMENT_DELAY 23'd0;
	read_index <= `BSV_ASSIGNMENT_DELAY 23'd0;
      end
    else
      begin
        if (golden_index$EN)
	  golden_index <= `BSV_ASSIGNMENT_DELAY golden_index$D_IN;
	if (read_index$EN)
	  read_index <= `BSV_ASSIGNMENT_DELAY read_index$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    golden_index = 23'h2AAAAA;
    read_index = 23'h2AAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_golden_output$EMPTY_N && fadd$receive[37] &&
	  fadd_receive__4_BITS_36_TO_5_6_EQ_ff_golden_ou_ETC___d19)
	$display("TB: Outputs match [%d], g: %h R: %h",
		 golden_index,
		 ff_golden_output$D_OUT[36:5],
		 fadd$receive[36:5]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_golden_output$EMPTY_N && fadd$receive[37] &&
	  !fadd_receive__4_BITS_36_TO_5_6_EQ_ff_golden_ou_ETC___d19)
	$display("TB: Outputs mismatch[%d]. G:%h R:%h,flag %h",
		 golden_index,
		 ff_golden_output$D_OUT[36:5],
		 fadd$receive[36:5],
		 fadd$receive[4:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_golden_output$EMPTY_N && fadd$receive[37] &&
	  (fadd$receive[4] != ff_golden_output$D_OUT[4] ||
	   fadd$receive[3] != ff_golden_output$D_OUT[3] ||
	   fadd$receive[2] != ff_golden_output$D_OUT[2] ||
	   fadd$receive[1] != ff_golden_output$D_OUT[1] ||
	   fadd$receive[0] != ff_golden_output$D_OUT[0]))
	$display("TB: Flags mismatch. G:%h R:%h",
		 ff_golden_output$D_OUT[4:0],
		 fadd$receive[4:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_golden_output$FULL_N)
	$display("TB: Sending inputs[%d]: op1:%h op2:%h, driven:%h, output %h",
		 read_index,
		 stimulus$D_OUT_1[103:72],
		 stimulus$D_OUT_1[71:40],
		 { stimulus$D_OUT_1[103:40], 3'd1 },
		 stimulus$D_OUT_1[39:8]);
    if (RST_N != `BSV_RESET_VALUE)
      if (ff_golden_output$FULL_N && read_index == 23'd500) $finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mktb_float

