//
// Generated by Bluespec Compiler, version 2021.12.1-27-g9a7d5e05 (build 9a7d5e05)
//
// On Mon Nov 28 14:29:12 IST 2022
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module tb_srt_radix4_divider(CLK,
			     RST_N);
  input  CLK;
  input  RST_N;

  // register en
  reg en;
  wire en$D_IN, en$EN;

  // register rg_cnt
  reg [5 : 0] rg_cnt;
  wire [5 : 0] rg_cnt$D_IN;
  wire rg_cnt$EN;

  // register rg_cycle
  reg [31 : 0] rg_cycle;
  wire [31 : 0] rg_cycle$D_IN;
  wire rg_cycle$EN;

  // register rg_funct3
  reg [2 : 0] rg_funct3;
  wire [2 : 0] rg_funct3$D_IN;
  wire rg_funct3$EN;

  // register rg_opcode
  reg [3 : 0] rg_opcode;
  wire [3 : 0] rg_opcode$D_IN;
  wire rg_opcode$EN;

  // ports of submodule ifc_div
  reg [3 : 0] ifc_div$ma_start_opcode;
  reg [2 : 0] ifc_div$ma_start_funct3;
  wire [64 : 0] ifc_div$mav_result;
  wire [63 : 0] ifc_div$ma_start_dividend, ifc_div$ma_start_divisor;
  wire ifc_div$EN_ma_set_flush,
       ifc_div$EN_ma_start,
       ifc_div$EN_mav_result,
       ifc_div$ma_set_flush_c;

  // rule scheduling signals
  wire WILL_FIRE_RL_rl_stage_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg [63 : 0] v__h1236;
  // synopsys translate_on

  // remaining internal signals
  wire [31 : 0] x__h363;

  // submodule ifc_div
  mk_srt_radix4_divider ifc_div(.CLK(CLK),
				.RST_N(RST_N),
				.ma_set_flush_c(ifc_div$ma_set_flush_c),
				.ma_start_dividend(ifc_div$ma_start_dividend),
				.ma_start_divisor(ifc_div$ma_start_divisor),
				.ma_start_funct3(ifc_div$ma_start_funct3),
				.ma_start_opcode(ifc_div$ma_start_opcode),
				.EN_ma_start(ifc_div$EN_ma_start),
				.EN_mav_result(ifc_div$EN_mav_result),
				.EN_ma_set_flush(ifc_div$EN_ma_set_flush),
				.RDY_ma_start(),
				.mav_result(ifc_div$mav_result),
				.RDY_mav_result(),
				.RDY_ma_set_flush());

  // rule RL_rl_stage_1
  assign WILL_FIRE_RL_rl_stage_1 = x__h363 == 32'd0 && rg_cycle != 32'd0 ;

  // register en
  assign en$D_IN = 1'b0 ;
  assign en$EN = 1'b0 ;

  // register rg_cnt
  assign rg_cnt$D_IN = rg_cnt + 6'd1 ;
  assign rg_cnt$EN =
	     WILL_FIRE_RL_rl_stage_1 &&
	     (rg_cnt == 6'd0 || rg_cnt == 6'd1 || rg_cnt == 6'd2 ||
	      rg_cnt == 6'd3 ||
	      rg_cnt == 6'd4 ||
	      rg_cnt == 6'd5 ||
	      rg_cnt == 6'd6 ||
	      rg_cnt == 6'd7) ;

  // register rg_cycle
  assign rg_cycle$D_IN = rg_cycle + 32'd1 ;
  assign rg_cycle$EN = 1'd1 ;

  // register rg_funct3
  assign rg_funct3$D_IN = 3'h0 ;
  assign rg_funct3$EN = 1'b0 ;

  // register rg_opcode
  assign rg_opcode$D_IN = 4'h0 ;
  assign rg_opcode$EN = 1'b0 ;

  // submodule ifc_div
  assign ifc_div$ma_set_flush_c = 1'b0 ;
  assign ifc_div$ma_start_dividend = 64'hCE9E3519A12FE4A4 ;
  assign ifc_div$ma_start_divisor = 64'h00000000312FE4A4 ;
  always@(rg_cnt)
  begin
    case (rg_cnt)
      6'd0, 6'd4: ifc_div$ma_start_funct3 = 3'b100;
      6'd1, 6'd5: ifc_div$ma_start_funct3 = 3'b101;
      6'd2, 6'd6: ifc_div$ma_start_funct3 = 3'b110;
      6'd3: ifc_div$ma_start_funct3 = 3'b111;
      default: ifc_div$ma_start_funct3 = 3'b111;
    endcase
  end
  always@(rg_cnt)
  begin
    case (rg_cnt)
      6'd0, 6'd1, 6'd2, 6'd3: ifc_div$ma_start_opcode = 4'b1100;
      default: ifc_div$ma_start_opcode = 4'b1110;
    endcase
  end
  assign ifc_div$EN_ma_start =
	     WILL_FIRE_RL_rl_stage_1 &&
	     (rg_cnt == 6'd0 || rg_cnt == 6'd1 || rg_cnt == 6'd2 ||
	      rg_cnt == 6'd3 ||
	      rg_cnt == 6'd4 ||
	      rg_cnt == 6'd5 ||
	      rg_cnt == 6'd6 ||
	      rg_cnt == 6'd7) ;
  assign ifc_div$EN_mav_result = 1'd1 ;
  assign ifc_div$EN_ma_set_flush = 1'b0 ;

  // remaining internal signals
  assign x__h363 = rg_cycle % 32'd39 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        en <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rg_cnt <= `BSV_ASSIGNMENT_DELAY 6'd0;
	rg_cycle <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_funct3 <= `BSV_ASSIGNMENT_DELAY 3'b101;
	rg_opcode <= `BSV_ASSIGNMENT_DELAY 4'b1100;
      end
    else
      begin
        if (en$EN) en <= `BSV_ASSIGNMENT_DELAY en$D_IN;
	if (rg_cnt$EN) rg_cnt <= `BSV_ASSIGNMENT_DELAY rg_cnt$D_IN;
	if (rg_cycle$EN) rg_cycle <= `BSV_ASSIGNMENT_DELAY rg_cycle$D_IN;
	if (rg_funct3$EN) rg_funct3 <= `BSV_ASSIGNMENT_DELAY rg_funct3$D_IN;
	if (rg_opcode$EN) rg_opcode <= `BSV_ASSIGNMENT_DELAY rg_opcode$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    en = 1'h0;
    rg_cnt = 6'h2A;
    rg_cycle = 32'hAAAAAAAA;
    rg_funct3 = 3'h2;
    rg_opcode = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64])
	begin
	  v__h1236 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (ifc_div$mav_result[64])
	$display(v__h1236,
		 " after updation Cycle %d => valid %d value %h",
		 rg_cycle,
		 ifc_div$mav_result[64],
		 ifc_div$mav_result[63:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd0)
	$display("%d DRIVE dividend %x", rg_cycle, 64'hCE9E3519A12FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd0)
	$display("%d DRIVE divisor %x", rg_cycle, 64'h00000000312FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd1)
	$display("%d DRIVE dividend %x", rg_cycle, 64'hCE9E3519A12FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd1)
	$display("%d DRIVE divisor %x", rg_cycle, 64'h00000000312FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd2)
	$display("%d DRIVE dividend %x", rg_cycle, 64'hCE9E3519A12FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd2)
	$display("%d DRIVE divisor %x", rg_cycle, 64'h00000000312FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd3)
	$display("%d DRIVE dividend %x", rg_cycle, 64'hCE9E3519A12FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd3)
	$display("%d DRIVE divisor %x", rg_cycle, 64'h00000000312FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd4)
	$display("%d DRIVE dividend %x", rg_cycle, 64'hCE9E3519A12FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd4)
	$display("%d DRIVE divisor %x", rg_cycle, 64'h00000000312FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd5)
	$display("%d DRIVE dividend %x", rg_cycle, 64'hCE9E3519A12FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd5)
	$display("%d DRIVE divisor %x", rg_cycle, 64'h00000000312FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd6)
	$display("%d DRIVE dividend %x", rg_cycle, 64'hCE9E3519A12FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd6)
	$display("%d DRIVE divisor %x", rg_cycle, 64'h00000000312FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd7)
	$display("%d DRIVE dividend %x", rg_cycle, 64'hCE9E3519A12FE4A4);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_stage_1 && rg_cnt == 6'd7)
	$display("%d DRIVE divisor %x", rg_cycle, 64'h00000000312FE4A4);
    if (RST_N != `BSV_RESET_VALUE) if (rg_cycle == 32'd400) $finish(32'd0);
  end
  // synopsys translate_on
endmodule  // tb_srt_radix4_divider

